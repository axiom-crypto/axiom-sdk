export const axiomDocs = "// Generated by dts-bundle-generator v8.0.1\n\n\ndeclare class CircuitValue {\n\tprivate _value;\n\tprivate _cell;\n\tconstructor(circuit: Halo2Wasm, { value, cell }: {\n\t\tvalue?: bigint | number | string;\n\t\tcell?: number;\n\t});\n\tcell(): number;\n\tvalue(): bigint;\n\tnumber(): number;\n\taddress(): string;\n}\n\ntype RawCircuitInput = string | number | bigint;\n\n/**\n * Creates a circuit variable from a number, bigint, or string.\n *\n * @param a The raw circuit input.\n * @returns The witness cell.\n */\ndeclare const witness: (a: RawCircuitInput) => CircuitValue;\n/**\n * Creates a circuit constant from a number, bigint, or string.\n *\n * @param a The raw circuit input.\n * @returns The constant cell.\n */\ndeclare const constant: (a: RawCircuitInput) => CircuitValue;\n/**\n * Adds two circuit values.\n *\n * @param a The first circuit value.\n * @param b The second circuit value.\n * @returns The sum of the two circuit values.\n */\ndeclare const add: (a: CircuitValue, b: CircuitValue) => CircuitValue;\n/**\n * Subtracts the second circuit value from the first circuit value.\n *\n * @param a The first circuit value.\n * @param b The second circuit value.\n * @returns The difference between the two circuit values.\n */\ndeclare const sub: (a: CircuitValue, b: CircuitValue) => CircuitValue;\n/**\n * Negates a circuit value.\n *\n * @param a The circuit value to negate.\n * @returns The negation of the circuit value.\n */\ndeclare const neg: (a: CircuitValue) => CircuitValue;\n/**\n * Multiplies two circuit values.\n *\n * @param a The first circuit value.\n * @param b The second circuit value.\n * @returns The product of the two circuit values.\n */\ndeclare const mul: (a: CircuitValue, b: CircuitValue) => CircuitValue;\n/**\n * Multiplies two circuit values and adds a third circuit value.\n *\n * @param a The first circuit value.\n * @param b The second circuit value.\n * @param c The third circuit value.\n * @returns The result of multiplying the first two circuit values and adding the third circuit value.\n */\ndeclare const mulAdd: (a: CircuitValue, b: CircuitValue, c: CircuitValue) => CircuitValue;\n/**\n * Multiplies a circuit value by the negation of another circuit value.\n *\n * @param a The first circuit value.\n * @param b The second circuit value.\n * @returns The result of multiplying the first circuit value by the negation of the second circuit value.\n */\ndeclare const mulNot: (a: CircuitValue, b: CircuitValue) => CircuitValue;\n/**\n * Asserts that a circuit value is a bit.\n *\n * @param a The circuit value to assert.\n */\ndeclare const assertBit: (a: CircuitValue) => void;\n/**\n * Asserts that a circuit value is a constant.\n *\n * @param a The circuit value to assert.\n * @param b The raw circuit input.\n */\ndeclare const assertIsConst: (a: CircuitValue, b: RawCircuitInput) => void;\n/**\n * Computes the inner product of two arrays of circuit values.\n *\n * @param a The first array of circuit values.\n * @param b The second array of circuit values.\n * @returns The inner product of the two arrays.\n */\ndeclare const innerProduct: (a: CircuitValue[], b: CircuitValue[]) => CircuitValue;\n/**\n * Computes the sum of an array of circuit values.\n *\n * @param arr The array of circuit values.\n * @returns The sum of the array of circuit values.\n */\ndeclare const sum: (arr: CircuitValue[]) => CircuitValue;\n/**\n * Performs a bitwise AND operation on two circuit values.\n *\n * @param a The first circuit value.\n * @param b The second circuit value.\n * @returns The result of the bitwise AND operation.\n */\ndeclare const and: (a: CircuitValue, b: CircuitValue) => CircuitValue;\n/**\n * Performs a bitwise OR operation on two circuit values.\n *\n * @param a The first circuit value.\n * @param b The second circuit value.\n * @returns The result of the bitwise OR operation.\n */\ndeclare const or: (a: CircuitValue, b: CircuitValue) => CircuitValue;\n/**\n * Performs a bitwise NOT operation on a circuit value.\n *\n * @param a The circuit value.\n * @returns The result of the bitwise NOT operation.\n */\ndeclare const not: (a: CircuitValue) => CircuitValue;\n/**\n * Decrements a circuit value by 1.\n *\n * @param a The circuit value.\n * @returns The decremented circuit value.\n */\ndeclare const dec: (a: CircuitValue) => CircuitValue;\n/**\n * Selects a circuit value based on a condition.\n *\n * @param a The condition circuit value.\n * @param b The first circuit value.\n * @param c The second circuit value.\n * @returns The selected circuit value.\n */\ndeclare const select: (a: CircuitValue, b: CircuitValue, c: CircuitValue) => CircuitValue;\n/**\n * Performs a bitwise OR-AND operation on three circuit values.\n *\n * @param a The first circuit value.\n * @param b The second circuit value.\n * @param c The third circuit value.\n * @returns The result of the OR-AND operation.\n */\ndeclare const orAnd: (a: CircuitValue, b: CircuitValue, c: CircuitValue) => CircuitValue;\n/**\n * Converts an array of circuit values to an indicator array.\n *\n * @param bits The array of circuit values.\n * @returns The indicator circuit value.\n */\ndeclare const bitsToIndicator: (bits: CircuitValue[]) => CircuitValue[];\n/**\n * Converts an index circuit value to an indicator circuit value.\n *\n * @param idx The index circuit value.\n * @param len The length of the indicator circuit value.\n * @returns The indicator circuit value.\n */\ndeclare const idxToIndicator: (idx: CircuitValue, len: RawCircuitInput) => CircuitValue[];\n/**\n * Selects circuit values from an array based on an indicator circuit value.\n *\n * @param arr The array of circuit values.\n * @param indicator The indicator circuit value.\n * @returns The selected circuit values.\n */\ndeclare const selectByIndicator: (arr: CircuitValue[], indicator: CircuitValue[]) => CircuitValue;\n/**\n * Selects a circuit value from an array based on an index circuit value.\n *\n * @param arr The array of circuit values.\n * @param idx The index circuit value.\n * @returns The selected circuit value.\n */\ndeclare const selectFromIdx: (arr: CircuitValue[], idx: CircuitValue) => CircuitValue;\n/**\n * Checks if a circuit value is zero.\n *\n * @param a The circuit value to check.\n * @returns The indicator circuit value representing whether the input is zero.\n */\ndeclare const isZero: (a: CircuitValue) => CircuitValue;\n/**\n * Checks if two circuit values are equal.\n *\n * @param a The first circuit value.\n * @param b The second circuit value.\n * @returns The indicator circuit value representing whether the two inputs are equal.\n */\ndeclare const isEqual: (a: CircuitValue, b: CircuitValue) => CircuitValue;\n/**\n * Converts a circuit value to an array of bits.\n *\n * @param a The circuit value to convert.\n * @param len The length of the resulting bit array.\n * @returns The array of bits representing the input circuit value.\n */\ndeclare const numToBits: (a: CircuitValue, len: RawCircuitInput) => CircuitValue[];\n/**\n * Asserts that two circuit values are equal.\n *\n * @param a The first circuit value.\n * @param b The second circuit value.\n */\ndeclare const assertEqual: (a: CircuitValue, b: CircuitValue) => void;\n/**\n * Checks if a circuit value is within a specified range.\n *\n * @param a The circuit value to check.\n * @param b The range of the circuit value.\n */\ndeclare const rangeCheck: (a: CircuitValue, b: RawCircuitInput) => void;\n/**\n * Checks if the first circuit value is less than the second circuit value.\n *\n * @param a The first circuit value.\n * @param b The second circuit value.\n * @param c The range of the circuit values.\n */\ndeclare const checkLessThan: (a: CircuitValue, b: CircuitValue, c?: string) => void;\n/**\n * Checks if the first circuit value is less than the second circuit value.\n *\n * @param a The first circuit value.\n * @param b The second circuit value.\n * @param c The range of the circuit values.\n * @returns The indicator circuit value representing whether the first input is less than the second input.\n */\ndeclare const isLessThan: (a: CircuitValue, b: CircuitValue, c?: string) => CircuitValue;\n/**\n * Divides two circuit values and returns the quotient.\n *\n * @param a The dividend circuit value.\n * @param b The divisor circuit value.\n * @returns The quotient.\n *\n*/\ndeclare const div: (a: CircuitValue, b: CircuitValue, c?: string, d?: string) => CircuitValue;\n/**\n * Divides two circuit values and returns the remainder.\n *\n * @param a The dividend circuit value.\n * @param b The divisor circuit value.\n * @returns The remainder.\n *\n*/\ndeclare const mod: (a: CircuitValue, b: CircuitValue, c?: string, d?: string) => CircuitValue;\n/**\n * Raises a circuit value to the power of another circuit value.\n *\n * @param a The base circuit value.\n * @param b The exponent circuit value.\n * @returns The result of the exponentiation.\n */\ndeclare const pow: (a: CircuitValue, b: CircuitValue, c?: string) => CircuitValue;\n/**\n * Computes the Poseidon hash of multiple circuit values.\n *\n * @param args The circuit values to hash.\n * @returns The hash value.\n */\ndeclare const poseidon: (...args: CircuitValue[]) => CircuitValue;\n/**\n * Retrieves the value of a circuit value.\n *\n * @param a The circuit value.\n * @returns The value of the circuit value.\n */\ndeclare const value: (a: CircuitValue) => any;\n/**\n * Logs the provided *circuit* values to the console. Use `console.log` for normal logging.\n *\n * @param args The `CircuitValue`s to log.\n */\ndeclare const log: (...args: any) => void;\n/**\n * Makes a circuit value public.\n *\n * @param a The circuit value to make public.\n */\ndeclare const makePublic: (a: CircuitValue) => void;\ndeclare const console: {\n    /**\n     * Logs any *non CircuitValue* to the console. Use `log` for logging `CircuitValue`s.\n     * @param args The values to log.\n     */\n    log: (...args: any) => void;\n}\n// Generated by dts-bundle-generator v8.0.1\n\n\ndeclare enum HeaderField {\n\tParentHash = 0,\n\tSha3Uncles = 1,\n\tMiner = 2,\n\tStateRoot = 3,\n\tTransactionsRoot = 4,\n\tReceiptsRoot = 5,\n\tDifficulty = 7,\n\tNumber = 8,\n\tGasLimit = 9,\n\tGasUsed = 10,\n\tTimestamp = 11,\n\tExtraData = 12,\n\tMixHash = 13,\n\tNonce = 14,\n\tBaseFeePerGas = 15,\n\tWithdrawalsRoot = 16,\n\tHash = 17,\n\tSize = 18\n}\ndeclare enum AccountField {\n\tNonce = 0,\n\tBalance = 1,\n\tStorageRoot = 2,\n\tCodeHash = 3\n}\ndeclare enum TxField {\n\tChainId = 0,\n\tNonce = 1,\n\tMaxPriorityFeePerGas = 2,\n\tMaxFeePerGas = 3,\n\tGasLimit = 4,\n\tTo = 5,\n\tValue = 6,\n\tData = 7,\n\tGasPrice = 8,\n\tv = 9,\n\tr = 10,\n\ts = 11\n}\ndeclare enum ReceiptField {\n\tStatus = 0,\n\tPostState = 1,\n\tCumulativeGas = 2,\n\tLogs = 4\n}\ndeclare class CircuitValue256 {\n\tprivate _value;\n\tprivate circuitValue;\n\tprivate circuit;\n\tconstructor(circuit: Halo2Wasm, { value, hi, lo }: {\n\t\tvalue?: bigint | string | number;\n\t\thi?: CircuitValue;\n\t\tlo?: CircuitValue;\n\t});\n\thi(): CircuitValue;\n\tlo(): CircuitValue;\n\thex(): string;\n\tvalue(): bigint;\n\ttoCircuitValue(): CircuitValue;\n}\ntype AccountEnumKeys = Uncapitalize<keyof typeof AccountField>;\ntype AccountEnumKeyFields = {\n\t[key in AccountEnumKeys]: () => CircuitValue256;\n};\ninterface Account extends AccountEnumKeyFields {\n}\n/**\n * Represents a log entry in a receipt.\n */\ninterface Log {\n\t/**\n\t * Retrieves the value of a specific topic in the log entry.\n\t *\n\t * @param topicIdx The index of the topic.\n\t * @param eventSchema The event schema.\n\t * @returns A `CircuitValue` representing the value of the topic.\n\t */\n\ttopic: (topicIdx: RawCircuitInput | CircuitValue, eventSchema?: string | CircuitValue256) => CircuitValue256;\n\t/**\n\t * Retrieves the address a log was emitted from\n\t *\n\t * @returns A `CircuitValue` representing `Log.address`.\n\t */\n\taddress: () => CircuitValue256;\n\t/**\n\t * Retrieves a 32 byte chunk of a log's data field.\n\t *\n\t * @param dataIdx The index of the 32 byte chunk\n\t * @param eventSchema The event schema.\n\t * @returns A `CircuitValue256` representing the 32 byte chunk of the log data.\n\t */\n\tdata: (dataIdx: CircuitValue | RawCircuitInput, eventSchema?: string | CircuitValue256) => CircuitValue256;\n}\ntype ReceiptEnumKeys = Uncapitalize<keyof typeof ReceiptField>;\ntype ReceiptEnumKeyFieldsUnfiltered = {\n\t[key in ReceiptEnumKeys]: () => CircuitValue256;\n};\ntype ReceiptEnumKeyFields = Omit<ReceiptEnumKeyFieldsUnfiltered, \"logs\" | \"postState\" | \"logsBloom\">;\ndeclare enum SpecialReceiptField {\n\tTxType = 51,\n\tBlockNumber = 52,\n\tTxIdx = 53\n}\ntype SpecialReceiptKeys = Uncapitalize<keyof typeof SpecialReceiptField>;\ntype SpecialReceiptKeyFields = {\n\t[key in SpecialReceiptKeys]: () => CircuitValue256;\n};\n/**\n * Represents a receipt.\n */\ninterface Receipt extends ReceiptEnumKeyFields, SpecialReceiptKeyFields {\n\t/**\n\t * Retrieves a log entry in the receipt.\n\t *\n\t * @param logIdx The index of the log entry.\n\t * @returns A `Log` object representing the log entry.\n\t */\n\tlog: (logIdx: RawCircuitInput | CircuitValue) => Log;\n\t/**\n\t * Retrieves a 32 byte chunk of the logs bloom.\n\t *\n\t * @param logsBloomIdx The index of the 32 byte chunk in [0,8)\n\t * @returns A `CircuitValue256` representing the 32 byte chunk of the logs bloom.\n\t */\n\tlogsBloom: (logsBloomIdx: RawCircuitInput) => CircuitValue256;\n}\ntype HeaderEnumKeys = Uncapitalize<keyof typeof HeaderField>;\ntype HeaderEnumKeyFieldsUnfiltered = {\n\t[key in HeaderEnumKeys]: () => CircuitValue256;\n};\ntype HeaderEnumKeyFields = Omit<HeaderEnumKeyFieldsUnfiltered, \"logsBloom\">;\ninterface Header extends HeaderEnumKeyFields {\n\t/**\n\t * Retrieves a 32 byte chunk of the logs bloom.\n\t *\n\t * @param logsBloomIdx The index of the 32 byte chunk in [0,8)\n\t * @returns A `CircuitValue256` in representing the 32 byte chunk of the logs bloom.\n\t */\n\tlogsBloom: (logsBloomIdx: RawCircuitInput) => CircuitValue256;\n}\n/**\n * Represents the storage of a contract.\n */\ninterface Storage {\n\t/**\n\t * Retrieves the value stored at a specific slot in the contract's storage.\n\t *\n\t * @param slot - The slot to retrieve the value from.\n\t * @returns A `CircuitValue` representing the value stored at the slot.\n\t */\n\tslot: (slot: RawCircuitInput | CircuitValue256 | CircuitValue) => CircuitValue256;\n}\ndeclare enum SpecialTxFields {\n\tType = 51,\n\tBlockNumber = 52,\n\tTxIdx = 53,\n\tFunctionSelector = 54,\n}\ntype SpecialTxKeys = Uncapitalize<keyof typeof SpecialTxFields>;\ntype SpecialTxKeyFields = {\n\t[key in SpecialTxKeys]: () => CircuitValue256;\n};\ntype TxEnumKeys = Uncapitalize<keyof typeof TxField>;\ntype TxEnumKeyFields = {\n\t[key in TxEnumKeys]: () => CircuitValue256;\n};\ninterface BaseTx extends TxEnumKeyFields {\n}\ninterface SpecialTx extends SpecialTxKeyFields {\n}\ninterface Tx extends BaseTx, SpecialTx {\n\t/**\n\t * Retrieves a 32 byte chunk of the transaction calldata.\n\t *\n\t * @param calldataIdx The index of the 32 byte chunk\n\t * @returns A `CircuitValue256` in representing the 32 byte chunk of the tx calldata.\n\t */\n\tcalldata: (calldataIdx: CircuitValue | RawCircuitInput) => CircuitValue256;\n\t/**\n\t * Retrieves a 32 byte chunk of a contract deployment's transaction data.\n\t *\n\t * @param contractDataIdx The index of the 32 byte chunk\n\t * @returns A `CircuitValue256` in representing the 32 byte chunk of the contract deploy data.\n\t */\n\tcontractData: (contractDataIdx: CircuitValue | RawCircuitInput) => CircuitValue256;\n}\ninterface SolidityMapping {\n\t/**\n\t * Retrieves the value of a specific key in the mapping.\n\t *\n\t * @param key The key of the mapping.\n\t * @returns A `CircuitValue` representing the value of the key in the mapping.\n\t */\n\tkey: (key: RawCircuitInput | CircuitValue256 | CircuitValue) => CircuitValue256;\n\t/**\n\t * Retrieves the value of a nested mapping at a specific depth and with specific keys.\n\t *\n\t * @param mappingDepth The depth of the nested mapping.\n\t * @param keys The keys to access the nested mapping.\n\t * @returns A `CircuitValue` representing the value of the nested mapping.\n\t */\n\tnested: (keys: (RawCircuitInput | CircuitValue256 | CircuitValue)[]) => CircuitValue256;\n}\ntype RawCircuitInput = string | number | bigint;\n/**\n * Retrieves the account information for a specific block and address.\n *\n * @param blockNumber The block number.\n * @param address The address of the account.\n * @returns An `Account` object to fetch individual account fields.\n */\ndeclare const getAccount: (blockNumber: number | CircuitValue, address: string | CircuitValue) => Readonly<Account>;\n/**\n * Retrieves the receipt information for a specific transaction hash.\n *\n * @param blockNumber The block number\n * @param txIdx The transaction index in the block\n * @returns A `Receipt` object to fetch individual receipt fields.\n */\ndeclare const getReceipt: (blockNumber: number | CircuitValue, txIdx: number | CircuitValue) => Readonly<Receipt>;\n/**\n * Retrieves the storage information for a specific block and address.\n *\n * @param blockNumber The block number.\n * @param address The address of the contract.\n * @returns A `Storage` object to fetch individual storage slots.\n */\ndeclare const getStorage: (blockNumber: number | CircuitValue, address: string | CircuitValue) => Readonly<Storage>;\n/**\n * Retrieves the transaction information for a specific transaction hash.\n *\n * @param blockNumber The block number\n * @param txIdx The transaction index in the block\n * @returns A `Tx` object to fetch individual transaction fields.\n */\ndeclare const getTx: (blockNumber: number | CircuitValue, txIdx: number | CircuitValue) => Readonly<Tx>;\n/**\n * Retrieves the header information for a specific block number.\n *\n * @param blockNumber The block number.\n * @returns A `Header` object to fetch individual header fields.\n */\ndeclare const getHeader: (blockNumber: number | CircuitValue) => Readonly<Header>;\n/**\n * Retrieves the solidity mapping information for a specific block, address, and slot.\n *\n * @param blockNumber The block number.\n * @param address The address of the contract.\n * @param slot The slot of the mapping.\n * @returns A `SolidityMapping` object to fetch individual mapping slots.\n */\ndeclare const getSolidityMapping: (blockNumber: number | CircuitValue, address: string | CircuitValue, slot: number | bigint | string | CircuitValue256 | CircuitValue) => Readonly<SolidityMapping>;\n/**\n * Creates a `CircuitValue256` from a hi-lo `CircuitValue` pair.\n * \n * @param hi The hi `CircuitValue`.\n * @param lo The lo `CircuitValue`.\n * @returns A `CircuitValue256` object\n */\ndeclare const getCircuitValue256FromHiLo: (hi: CircuitValue, lo: CircuitValue) => CircuitValue256;\n/**\n * Creates a `CircuitValue256` from a `RawCircuitInput`.\n * \n * @param a The raw circuit input.\n * @returns A `CircuitValue256` witness object\n */\ndeclare const getCircuitValue256: (a: RawCircuitInput) => CircuitValue256;\n/**\n * Adds a circuit value to the callback.\n *\n * @param a The circuit value to add to the callback.\n */\ndeclare const addToCallback: (a: CircuitValue | CircuitValue256) => void;";